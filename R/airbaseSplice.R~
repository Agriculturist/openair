##' Function to simplify and combine airbase data imports
##'
##' Airbase keeps a detailed account of the instruments used for
##' measuring different species. For the same species several
##' different instruments can be used over time. For example, for NOx
##' a broken instrument could be replaced by a new one. In airbase
##' these two instruments will results in two separate time series
##' identified through the airbase measurement_european_group_code
##' (with numbers like 100, 101, 102). When data are imported using
##' the \code{importAirbase} function the different measurement codes
##' are retained in teh pollutant names if more than one code is used,
##' resulting in names like NOX|101, NOX|102 and so on.
##'
##' For \sQuote{simple} species such as NOx there is generally no reason to keep two separate time series and it would seem reasonable to combine them.
##' @title Function to simplify and combine airbase data imports
##' @param dat Data (a data frame) that has been imported using the
##' \code{importAirbase} function.
##' @param drop Should the original columns be dropped or kept. The
##' default is to remove (drop) them.
##' @export
##' @return A simplified data frame.
##' @author David Carslaw
airbaseSplice <- function(dat, drop = TRUE) {
    ## strip out pollutant name
    poll.nm <- names(dat)
    poll.nm <- lapply(poll.nm, function (x) strsplit(x, split = "\\|")[[1]][1])
    poll.nm <- do.call(c, poll.nm)

    all.ids <- NULL ## ids of columns to remove if drop = TRUE
    ## if pollutant name repeats then combine
    for (j in seq_along(poll.nm)) {

        ## means that there is more than one instrument and need to combine
        if (length(which(poll.nm == poll.nm[j])) != 1) {
            
            id <- which(poll.nm == poll.nm[j]) 
            new.nm <- poll.nm[id[1]] ## just use first for new name

            ## will combine by adding latest measurements last
            ## do this in case of overlap
            res <- sapply(id, function (x) max(na.omit(dat[, c(1, x)])$date))
            res <- data.frame(max.date = res, id = id)

            ## sort lowest to highest
            res <- sortDataFrame(res, key = "max.date")

            for (k in 1:nrow(res)) {
                if (k == 1) {
                    dat[ , new.nm] <- dat[, res$id[k]] ## make new variable
                } else {
                    ids <- which(!is.na(dat[, res$id[k]]))
                    dat[ids, new.nm] <- dat[ids, res$id[k]]
                }               
            }
            
            all.ids <- c(all.ids, id)
        }           
    }

    if (drop & length(all.ids) > 0) dat <- dat[, -all.ids] ## remove original columns
    dat  
}
